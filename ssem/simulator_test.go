package ssem

import (
	"strconv"
	"testing"
	"time"
)

func storeFromSnapshot(snp []string) Store {
	s := Store{}
	for i := range snp {
		w, _ := strconv.ParseInt(Reverse(snp[i]), 2, 33)
		s[i] = Word(w)
	}
	return s
}

// This program uses every function.
// Store line 16 should decrement from 1024 and then stop showing -1.
func TestFunctionalAll(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"10000000000000000000000000000000", // 00: JMP 01
		"01010000000000100000000000000000", // 01: LDN 10
		"00000000000000010000000000000000", // 02: SUB 00
		"00001000000001100000000000000000", // 03: STO 16
		"00000000000000110000000000000000", // 04: CMP 00
		"00000000000000000000000000000000", // 05: JMP 00
		"00000000000001000000000000000000", // 06: JRP 00
		"00000000000000000000000000000000", // 07: JMP 00
		"00000000000001110000000000000000", // 08: STP 00
		"00000000000000000000000000000000", // 09:
		"00000111111111111111111111111111", // 10: NUM -1024
		"00000000000000000000000000000000", // 11:
		"00000000000000000000000000000000", // 12:
		"00000000000000000000000000000000", // 13:
		"00000000000000000000000000000000", // 14:
		"00000000000000000000000000000000", // 15:
		"00000000000000000000000000000000", // 16: NUM 0
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
	})

	expected_store := storeFromSnapshot([]string{
		"10000000000000000000000000000000",
		"01010000000000100000000000000000",
		"00000000000000010000000000000000",
		"00001000000001100000000000000000",
		"00000000000000110000000000000000",
		"00000000000000000000000000000000",
		"00000000000001000000000000000000",
		"00000000000000000000000000000000",
		"00000000000001110000000000000000",
		"00000000000000000000000000000000",
		"00000111111111111111111111111111",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"11111111111111111111111111111111", // 16: -1
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 131, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed Combined Functions Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("combined Functions Test timed out")
	}
}

func TestFunctionalCmp1(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"01111000000001100000000000000000",
		"01111000000000100000000000000000",
		"11001000000000010000000000000000",
		"11111000000001100000000000000000",
		"00000000000000110000000000000000",
		"11001000000001000000000000000000",
		"00000000000001110000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000100000000000000000000000000",
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"01111000000001100000000000000000",
		"01111000000000100000000000000000",
		"11001000000000010000000000000000",
		"11111000000001100000000000000000",
		"00000000000000110000000000000000",
		"11001000000001000000000000000000",
		"00000000000001110000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"11111111111111111111111111111111",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 300, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed CMP1 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("CMP1 Test timed out")
	}
}

func TestFunctionalCmp2(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"11001000000000010000000000000000",
		"01111000000001100000000000000000",
		"01111000000000100000000000000000",
		"11111000000001100000000000000000",
		"00000000000000110000000000000000",
		"00000000000001110000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000111111111111111111111111111",
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"11001000000000010000000000000000",
		"01111000000001100000000000000000",
		"01111000000000100000000000000000",
		"11111000000001100000000000000000",
		"00000000000000110000000000000000",
		"00000000000001110000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 300, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed CMP2 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("CMP2 Test timed out")
	}
}

func TestFunctionalJmp1(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"01000000000000000000000000000000",
		"11000000000000000000000000000000",
		"00100000000000000000000000000000",
		"10100000000000000000000000000000",
		"01100000000000000000000000000000",
		"11100000000000000000000000000000",
		"00010000000000000000000000000000",
		"10010000000000000000000000000000",
		"01010000000000000000000000000000",
		"11010000000000000000000000000000",
		"00110000000000000000000000000000",
		"10110000000000000000000000000000",
		"01110000000000000000000000000000",
		"11110000000000000000000000000000",
		"00001000000000000000000000000000",
		"10001000000000000000000000000000",
		"01001000000000000000000000000000",
		"11001000000000000000000000000000",
		"00101000000000000000000000000000",
		"10101000000000000000000000000000",
		"01101000000000000000000000000000",
		"11101000000000000000000000000000",
		"00011000000000000000000000000000",
		"10011000000000000000000000000000",
		"01011000000000000000000000000000",
		"11011000000000000000000000000000",
		"00111000000000000000000000000000",
		"10111000000000000000000000000000",
		"01111000000000000000000000000000",
		"11111000000000000000000000000000",
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"01000000000000000000000000000000",
		"11000000000000000000000000000000",
		"00100000000000000000000000000000",
		"10100000000000000000000000000000",
		"01100000000000000000000000000000",
		"11100000000000000000000000000000",
		"00010000000000000000000000000000",
		"10010000000000000000000000000000",
		"01010000000000000000000000000000",
		"11010000000000000000000000000000",
		"00110000000000000000000000000000",
		"10110000000000000000000000000000",
		"01110000000000000000000000000000",
		"11110000000000000000000000000000",
		"00001000000000000000000000000000",
		"10001000000000000000000000000000",
		"01001000000000000000000000000000",
		"11001000000000000000000000000000",
		"00101000000000000000000000000000",
		"10101000000000000000000000000000",
		"01101000000000000000000000000000",
		"11101000000000000000000000000000",
		"00011000000000000000000000000000",
		"10011000000000000000000000000000",
		"01011000000000000000000000000000",
		"11011000000000000000000000000000",
		"00111000000000000000000000000000",
		"10111000000000000000000000000000",
		"01111000000000000000000000000000",
		"11111000000000000000000000000000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 31, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed JMP1 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("JMP1 Test timed out")
	}
}

func TestFunctionalJrp1(t *testing.T) {
	// TODO: include behavioral testing at each step, not just the end state
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"01111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11011000000000000000000000000000",
		"01111111111111111111111111111111",
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"01111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11111000000001000000000000000000",
		"11011000000000000000000000000000",
		"01111111111111111111111111111111",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 30, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed JRP1 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("JRP1 Test timed out")
	}
}

func TestFunctionalLdn1(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00:           0  JMP 00
		"10000000000000100000000000000000", // 01:       16385  LDN 01
		"01000000000000100000000000000000", // 02:       16386  LDN 02
		"11000000000000100000000000000000", // 03:       16387  LDN 03
		"00100000000000100000000000000000", // 04:       16388  LDN 04
		"10100000000000100000000000000000", // 05:       16389  LDN 05
		"01100000000000100000000000000000", // 06:       16390  LDN 06
		"11100000000000100000000000000000", // 07:       16391  LDN 07
		"00010000000000100000000000000000", // 08:       16392  LDN 08
		"10010000000000100000000000000000", // 09:       16393  LDN 09
		"01010000000000100000000000000000", // 10:       16394  LDN 10
		"11010000000000100000000000000000", // 11:       16395  LDN 11
		"00110000000000100000000000000000", // 12:       16396  LDN 12
		"10110000000000100000000000000000", // 13:       16397  LDN 13
		"01110000000000100000000000000000", // 14:       16398  LDN 14
		"11110000000000100000000000000000", // 15:       16399  LDN 15
		"00001000000000100000000000000000", // 16:       16400  LDN 16
		"10001000000000100000000000000000", // 17:       16401  LDN 17
		"01001000000000100000000000000000", // 18:       16402  LDN 18
		"11001000000000100000000000000000", // 19:       16403  LDN 19
		"00101000000000100000000000000000", // 20:       16404  LDN 20
		"10101000000000100000000000000000", // 21:       16405  LDN 21
		"01101000000000100000000000000000", // 22:       16406  LDN 22
		"11101000000000100000000000000000", // 23:       16407  LDN 23
		"00011000000000100000000000000000", // 24:       16408  LDN 24
		"10011000000000100000000000000000", // 25:       16409  LDN 25
		"01011000000000100000000000000000", // 26:       16410  LDN 26
		"11011000000000100000000000000000", // 27:       16411  LDN 27
		"00111000000000100000000000000000", // 28:       16412  LDN 28
		"10111000000000100000000000000000", // 29:       16413  LDN 29
		"01111000000000100000000000000000", // 30:       16414  LDN 30
		"11111000000000100000000000000000", // 31:       16415  LDN 31
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"10000000000000100000000000000000",
		"01000000000000100000000000000000",
		"11000000000000100000000000000000",
		"00100000000000100000000000000000",
		"10100000000000100000000000000000",
		"01100000000000100000000000000000",
		"11100000000000100000000000000000",
		"00010000000000100000000000000000",
		"10010000000000100000000000000000",
		"01010000000000100000000000000000",
		"11010000000000100000000000000000",
		"00110000000000100000000000000000",
		"10110000000000100000000000000000",
		"01110000000000100000000000000000",
		"11110000000000100000000000000000",
		"00001000000000100000000000000000",
		"10001000000000100000000000000000",
		"01001000000000100000000000000000",
		"11001000000000100000000000000000",
		"00101000000000100000000000000000",
		"10101000000000100000000000000000",
		"01101000000000100000000000000000",
		"11101000000000100000000000000000",
		"00011000000000100000000000000000",
		"10011000000000100000000000000000",
		"01011000000000100000000000000000",
		"11011000000000100000000000000000",
		"00111000000000100000000000000000",
		"10111000000000100000000000000000",
		"01111000000000100000000000000000",
		"11111000000000100000000000000000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false

	var valuesOfA [34]Word
	for i := range 34 {
		valuesOfA[i] = s.a
		s.InstructionCycle()
	}
	if valuesOfA != [34]Word{
		0, -16385, -16386, -16387, -16388, -16389, -16390, -16391,
		-16392, -16393, -16394, -16395, -16396, -16397, -16398, -16399,
		-16400, -16401, -16402, -16403, -16404, -16405, -16406, -16407,
		-16408, -16409, -16410, -16411, -16412, -16413, -16414, -16415,
		-16415, -16385,
	} {
		t.Errorf("failed LDN1 Test")
	}
	if s.store != expected_store {
		t.Errorf("failed LDN1 Test")
	}
}

func TestFunctionalSto1(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00:           0
		"11111000000000100000000000000000", // 01:       16415  LDN 31
		"01000000000001100000000000000000", // 02:       24578  STO 02
		"11000000000001100000000000000000", // 03:       24579  STO 03
		"00100000000001100000000000000000", // 04:       24580  STO 04
		"10100000000001100000000000000000", // 05:       24581  STO 05
		"01100000000001100000000000000000", // 06:       24582  STO 06
		"11100000000001100000000000000000", // 07:       24583  STO 07
		"00010000000001100000000000000000", // 08:       24584  STO 08
		"10010000000001100000000000000000", // 09:       24585  STO 09
		"01010000000001100000000000000000", // 10:       24586  STO 10
		"11010000000001100000000000000000", // 11:       24587  STO 11
		"00110000000001100000000000000000", // 12:       24588  STO 12
		"10110000000001100000000000000000", // 13:       24589  STO 13
		"01110000000001100000000000000000", // 14:       24590  STO 14
		"11110000000001100000000000000000", // 15:       24591  STO 15
		"00001000000001100000000000000000", // 16:       24592  STO 16
		"10001000000001100000000000000000", // 17:       24593  STO 17
		"01001000000001100000000000000000", // 18:       24594  STO 18
		"11001000000001100000000000000000", // 19:       24595  STO 19
		"00101000000001100000000000000000", // 20:       24596  STO 20
		"10101000000001100000000000000000", // 21:       24597  STO 21
		"01101000000001100000000000000000", // 22:       24598  STO 22
		"11101000000001100000000000000000", // 23:       24599  STO 23
		"00011000000001100000000000000000", // 24:       24600  STO 24
		"10011000000001100000000000000000", // 25:       24601  STO 25
		"01011000000001100000000000000000", // 26:       24602  STO 26
		"11011000000001100000000000000000", // 27:       24603  STO 27
		"00111000000001100000000000000000", // 28:       24604  STO 28
		"10111000000001100000000000000000", // 29:       24605  STO 29
		"00000000000001110000000000000000", // 30:       57344  STP 00
		"11010101010101010101010101010101", // 31: -1431655765
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"10101010101010101010101010101010",
		"00000000000001110000000000000000",
		"11010101010101010101010101010101",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 29, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed STO1 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("STO1 Test timed out")
	}
}

func TestFunctionalSto2(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00:           0
		"11111000000000100000000000000000", // 01:       16415  LDN 31
		"01000000000001100000000000000000", // 02:       24578  STO 02
		"11000000000001100000000000000000", // 03:       24579  STO 03
		"00100000000001100000000000000000", // 04:       24580  STO 04
		"10100000000001100000000000000000", // 05:       24581  STO 05
		"01100000000001100000000000000000", // 06:       24582  STO 06
		"11100000000001100000000000000000", // 07:       24583  STO 07
		"00010000000001100000000000000000", // 08:       24584  STO 08
		"10010000000001100000000000000000", // 09:       24585  STO 09
		"01010000000001100000000000000000", // 10:       24586  STO 10
		"11010000000001100000000000000000", // 11:       24587  STO 11
		"00110000000001100000000000000000", // 12:       24588  STO 12
		"10110000000001100000000000000000", // 13:       24589  STO 13
		"01110000000001100000000000000000", // 14:       24590  STO 14
		"11110000000001100000000000000000", // 15:       24591  STO 15
		"00001000000001100000000000000000", // 16:       24592  STO 16
		"10001000000001100000000000000000", // 17:       24593  STO 17
		"01001000000001100000000000000000", // 18:       24594  STO 18
		"11001000000001100000000000000000", // 19:       24595  STO 19
		"00101000000001100000000000000000", // 20:       24596  STO 20
		"10101000000001100000000000000000", // 21:       24597  STO 21
		"01101000000001100000000000000000", // 22:       24598  STO 22
		"11101000000001100000000000000000", // 23:       24599  STO 23
		"00011000000001100000000000000000", // 24:       24600  STO 24
		"10011000000001100000000000000000", // 25:       24601  STO 25
		"01011000000001100000000000000000", // 26:       24602  STO 26
		"11011000000001100000000000000000", // 27:       24603  STO 27
		"00111000000001100000000000000000", // 28:       24604  STO 28
		"10111000000001100000000000000000", // 29:       24605  STO 29
		"00000000000001110000000000000000", // 30:       57344  STP 00
		"01101010101010101010101010101010", // 31:  1431655766
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"11111000000000100000000000000000",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"01010101010101010101010101010101",
		"00000000000001110000000000000000",
		"01101010101010101010101010101010",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 29, 0)

	select {
	case <-cyclesChan:
		if s.store != expected_store {
			t.Errorf("failed STO2 Test")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("STO2 Test timed out")
	}
}

// This test repeatedly call the SUB instruction.
// After n cycles, the accumulator is expected to be -n (except once every 15 instructions where it is -n-1)
func TestFunctionalSub1(t *testing.T) {
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00:
		"10001000000000010000000000000000", // 01: SUB 17
		"10001000000000010000000000000000", // 02: SUB 17
		"10001000000000010000000000000000", // 03: SUB 17
		"10001000000000010000000000000000", // 04: SUB 17
		"10001000000000010000000000000000", // 05: SUB 17
		"10001000000000010000000000000000", // 06: SUB 17
		"10001000000000010000000000000000", // 07: SUB 17
		"10001000000000010000000000000000", // 08: SUB 17
		"10001000000000010000000000000000", // 09: SUB 17
		"10001000000000010000000000000000", // 10: SUB 17
		"10001000000000010000000000000000", // 11: SUB 17
		"10001000000000010000000000000000", // 12: SUB 17
		"10001000000000010000000000000000", // 13: SUB 17
		"10001000000000010000000000000000", // 14: SUB 17
		"01001000000000010000000000000000", // 15: SUB 18  ; Substract 2 to compensate for the next JMP instruction
		"00000000000000000000000000000000", // 16: JMP 00
		"10000000000000000000000000000000", // 17: NUM 01
		"01000000000000000000000000000000", // 18: NUM 02
		"00000000000001110000000000000000", // 19:
		"00000000000001110000000000000000", // 20:
		"00000000000001110000000000000000", // 21:
		"00000000000001110000000000000000", // 22:
		"00000000000001110000000000000000", // 23:
		"00000000000001110000000000000000", // 24:
		"00000000000001110000000000000000", // 25:
		"00000000000001110000000000000000", // 26:
		"00000000000001110000000000000000", // 27:
		"00000000000001110000000000000000", // 28:
		"00000000000001110000000000000000", // 29:
		"00000000000001110000000000000000", // 30:
		"00000000000001110000000000000000", // 31:
	})

	expected_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"10001000000000010000000000000000",
		"01001000000000010000000000000000",
		"00000000000000000000000000000000",
		"10000000000000000000000000000000",
		"01000000000000000000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
		"00000000000001110000000000000000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false

	var valuesOfA [16]Word
	for i := range 16 {
		valuesOfA[i] = s.a
		s.InstructionCycle()
	}
	if valuesOfA != [16]Word{0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -16} {
		t.Errorf("failed SUB1 Test")
	}
	if s.store != expected_store {
		t.Errorf("failed SUB1 Test")
	}
}

func TestFunctionalFactorct(t *testing.T) {
	// The first program was written by Tom Kilburn. It was a program to find the highest proper factor of any number a;
	// this was done by trying every integer b from a-1 downward until one was found that divided exactly into a.
	// The necessary divisions were done not by long division but by repeated subtraction of b
	// (because the "Baby" only had a hardware subtractor).
	//
	//    https://web.archive.org/web/20081006200609/http://www.computer50.org/mark1/firstprog.html
	//
	// When stopped, the answer will appear on line 27
	// With the number entered in the present file, it should be 131072
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00 JMP 0    ;
		"00011000000000100000000000000000", // 01 LDN 24   ; -24 to C
		"01011000000001100000000000000000", // 02 STO 26   ; C to 26
		"01011000000000100000000000000000", // 03 LDN 26   ; -26 to C
		"11011000000001100000000000000000", // 04 STO 27   ; C to 27
		"11101000000000100000000000000000", // 05 LDN 23   ; -23 to C
		"11011000000000010000000000000000", // 06 SUB 27   ; Sub 27
		"00000000000000110000000000000000", // 07 CMP      ; Test
		"00101000000001000000000000000000", // 08 JRP 20   ; Add 20 to [...]
		"01011000000000010000000000000000", // 09 SUB 26   ; Sub 26
		"10011000000001100000000000000000", // 10 STO 25   ; C to 25
		"10011000000000100000000000000000", // 11 LDN 25   ; -25 to C
		"00000000000000110000000000000000", // 12 CMP      ; Test
		"00000000000001110000000000000000", // 13 STP      ; Stop
		"01011000000000100000000000000000", // 14 LDN 26   ; -26 to C
		"10101000000000010000000000000000", // 15 SUB 21   ; Sub 21
		"11011000000001100000000000000000", // 16 STO 27   ; C to 27
		"11011000000000100000000000000000", // 17 LDN 27   ; -27 to C
		"01011000000001100000000000000000", // 18 STO 26   ; C to 26
		"01101000000000000000000000000000", // 19 JMP 22   ; 22 to [...]
		"10111111111111111111111111111111", // 20 NUM -3   ;
		"10000000000000000000000000000000", // 21 NUM 1    ;
		"00100000000000000000000000000000", // 22 NUM 4    ;
		"00000000000000000011111111111111", // 23 NUM -262144  ; Opposit of the following number
		"11111111111111111100000000000000", // 24 NUM 262143   ; the number to find the highest factor of
		"00000000000000000000000000000000", // 25 NUM 0    ;
		"00000000000000000000000000000000", // 26 NUM 0    ;
		"00000000000000000000000000000000", // 27 NUM 0    ; This line will hold the answer when finished
		"00000000000000000000000000000000", // 28 NUM 0    ;
		"00000000000000000000000000000000", // 29 NUM 0    ;
		"00000000000000000000000000000000", // 30 NUM 0    ;
		"00000000000000000000000000000000", // 31 NUM 0    ;
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 100000000, 0)

	select {
	case <-cyclesChan:
		if s.store[27] != 131072 {
			t.Errorf("failed TestFunctionalFactorct")
		}
	case <-time.After(3 * time.Second):
		t.Fatal("TestFunctionalFactorct timed out")
	}
}

func BenchmarkFactorct(b *testing.B) {
	// The first program was written by Tom Kilburn. It was a program to find the highest proper factor of any number a;
	// this was done by trying every integer b from a-1 downward until one was found that divided exactly into a.
	// The necessary divisions were done not by long division but by repeated subtraction of b
	// (because the "Baby" only had a hardware subtractor).
	//
	//    https://web.archive.org/web/20081006200609/http://www.computer50.org/mark1/firstprog.html
	//
	// When stopped, the answer will appear on line 27
	// With the number entered in the present file, it should be 131072
	initial_store := storeFromSnapshot([]string{
		"00000000000000000000000000000000", // 00 JMP 0    ;
		"00011000000000100000000000000000", // 01 LDN 24   ; -24 to C
		"01011000000001100000000000000000", // 02 STO 26   ; C to 26
		"01011000000000100000000000000000", // 03 LDN 26   ; -26 to C
		"11011000000001100000000000000000", // 04 STO 27   ; C to 27
		"11101000000000100000000000000000", // 05 LDN 23   ; -23 to C
		"11011000000000010000000000000000", // 06 SUB 27   ; Sub 27
		"00000000000000110000000000000000", // 07 CMP      ; Test
		"00101000000001000000000000000000", // 08 JRP 20   ; Add 20 to [...]
		"01011000000000010000000000000000", // 09 SUB 26   ; Sub 26
		"10011000000001100000000000000000", // 10 STO 25   ; C to 25
		"10011000000000100000000000000000", // 11 LDN 25   ; -25 to C
		"00000000000000110000000000000000", // 12 CMP      ; Test
		"00000000000001110000000000000000", // 13 STP      ; Stop
		"01011000000000100000000000000000", // 14 LDN 26   ; -26 to C
		"10101000000000010000000000000000", // 15 SUB 21   ; Sub 21
		"11011000000001100000000000000000", // 16 STO 27   ; C to 27
		"11011000000000100000000000000000", // 17 LDN 27   ; -27 to C
		"01011000000001100000000000000000", // 18 STO 26   ; C to 26
		"01101000000000000000000000000000", // 19 JMP 22   ; 22 to [...]
		"10111111111111111111111111111111", // 20 NUM -3   ;
		"10000000000000000000000000000000", // 21 NUM 1    ;
		"00100000000000000000000000000000", // 22 NUM 4    ;
		"00000000000000000011111111111111", // 23 NUM -262144  ; Opposit of the following number
		"11111111111111111100000000000000", // 24 NUM 262143   ; the number to find the highest factor of
		"00000000000000000000000000000000", // 25 NUM 0    ;
		"00000000000000000000000000000000", // 26 NUM 0    ;
		"00000000000000000000000000000000", // 27 NUM 0    ; This line will hold the answer when finished
		"00000000000000000000000000000000", // 28 NUM 0    ;
		"00000000000000000000000000000000", // 29 NUM 0    ;
		"00000000000000000000000000000000", // 30 NUM 0    ;
		"00000000000000000000000000000000", // 31 NUM 0    ;
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 100000000, 0)

	select {
	case <-cyclesChan:
		return
	case <-time.After(3 * time.Second):
		b.Fatal("BenchmarkFactorct timed out")
	}
}

func BenchmarkNightmare(b *testing.B) {
	initial_store := storeFromSnapshot([]string{
		"00000110101001000100000100000100",
		"10011011111100100010000010001000",
		"10000010000101101000100001010000",
		"00000010000100110100001001100000",
		"11101011111100011010101010010100",
		"10000000110000010001000010101001",
		"10000001111000010000100100001100",
		"10000001111000010000011000000010",
		"10011000000001101000011001000001",
		"10101001111000100100100100000010",
		"00000001111000110011010010000100",
		"01101001111000010011000001001000",
		"11101001111000010100100000110000",
		"10101000110001101000010000110000",
		"10100001111000010000001001001000",
		"00010011111101100000000110000100",
		"00000111111110010000000010000010",
		"10000011111101101111111111111111",
		"10101001111000100110011001100110",
		"10101000110001101111111111111111",
		"00011000110000001111111111111111",
		"01100000000000000000000000000000",
		"11100000000000000000000000000000",
		"11111111111111111111111111111111",
		"00000000000000000000000000000000",
		"00000000000000011111000000100000",
		"00000000000000100000100001010000",
		"00000000000000100010100000100000",
		"00000001111110100000100000111000",
		"00000010000000011111000000100000",
		"00011110011110001000000000100000",
		"00111111111111111110000001010000",
	})

	s := NewSsem()
	s.store = initial_store
	s.StopFlag = false
	cyclesChan := make(chan uint)

	go s.Run(cyclesChan, 100000000, 0)

	select {
	case <-cyclesChan:
		return
	case <-time.After(1 * time.Minute): // TODO: check why it does not always time out here
		b.Fatal("BenchmarkNightmare timed out")
	}
}
